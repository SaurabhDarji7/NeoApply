# NeoApply Coding Standards

## üéØ CORE ARCHITECTURAL PRINCIPLES (MUST FOLLOW)

### 1. SIMPLICITY FIRST - "You Aren't Gonna Need It" (YAGNI)

**BEFORE adding ANY abstraction, ask:**
- ‚ùì Do I have **3+ concrete use cases** RIGHT NOW that need this abstraction?
- ‚ùì Is this solving an **actual problem** or a **hypothetical future problem**?
- ‚ùì Can I solve this with **simple configuration** instead of inheritance/patterns?

**Rules:**
- ‚úÖ START with the simplest solution that works
- ‚úÖ ADD abstraction only when you have concrete duplication
- ‚úÖ PREFER configuration over inheritance
- ‚úÖ PREFER simple functions over complex patterns
- ‚ùå NEVER create "BaseX" classes until you have 3+ similar classes
- ‚ùå NEVER create registries/factories unless absolutely necessary
- ‚ùå NEVER create separate files for tiny classes (< 30 lines)

**Decision Tree for Abstraction:**
```
Need to do something similar in multiple places?
‚îú‚îÄ Same code in 2 places?
‚îÇ  ‚îî‚îÄ Just use a method with parameters (NO abstraction yet)
‚îú‚îÄ Same code in 3+ places?
‚îÇ  ‚îî‚îÄ Extract to a service/module with configuration
‚îî‚îÄ 5+ places AND complex logic?
   ‚îî‚îÄ NOW consider base classes/patterns
```

### 2. MEASURE COMPLEXITY - Keep It Under Control

**Before committing code, check:**
- Lines per file: < 200 (split if larger)
- Lines per method: < 20 (extract if larger)
- Classes per domain: < 5 (simplify if more)
- Abstraction layers: < 3 (flatten if more)

**Red Flags:**
- üö© "Base" classes with only 1-2 subclasses ‚Üí Over-engineering
- üö© Classes that just pass configuration ‚Üí Over-engineering
- üö© More than 3 levels of inheritance ‚Üí Over-engineering
- üö© Registries/factories with < 5 registered types ‚Üí Over-engineering
- üö© Template method pattern for simple config ‚Üí Over-engineering

### 3. RAILS CONVENTIONS - Follow The Rails Way

**When Rails provides a solution, USE IT:**
- ‚úÖ Use initializers for app setup (`config/initializers/`)
- ‚úÖ Use Rails.application.config for configuration
- ‚úÖ Use ActiveSupport::Concern for shared behavior
- ‚úÖ Use Rails naming conventions (no creative names)
- ‚úÖ Use service objects with `.call` for business logic
- ‚ùå Don't create your own registry/plugin systems
- ‚ùå Don't fight Rails conventions

**Example - Configuration:**
```ruby
# ‚ùå BAD: Custom registry
class MyRegistry
  def self.register(type, klass); end
end

# ‚úÖ GOOD: Simple Rails config
# config/initializers/my_config.rb
Rails.application.config.parsers = {
  resume: ResumeParser,
  job: JobParser
}
```

### 4. EXTENSIBILITY - Make It Easy to Extend, Not Complex

**Extensibility ‚â† Complexity**

Good extensibility:
- ‚úÖ Pass different parameters to same function
- ‚úÖ Add new cases to case/when or hash lookup
- ‚úÖ Create new service class and call it
- ‚úÖ Add new initializer file

Bad extensibility (over-engineering):
- ‚ùå Create inheritance hierarchy for simple variations
- ‚ùå Build plugin/registry systems
- ‚ùå Abstract everything "just in case"
- ‚ùå Create frameworks within your app

**Example:**
```ruby
# ‚ùå BAD: Over-engineered
class BaseParser; end
class ResumeParser < BaseParser; end
class JobParser < BaseParser; end
ParserRegistry.register(:resume, ResumeParser)

# ‚úÖ GOOD: Simple and extensible
class Parser
  def self.parse(text, schema:, validator:)
    # ...
  end
end

# Easy to extend - just pass different config!
Parser.parse(text, schema: ResumeSchema, validator: ->(d) { ... })
Parser.parse(text, schema: JobSchema, validator: ->(d) { ... })
```

### 5. REUSABILITY - Extract When You Have Duplication, Not Before

**The Rule of Three:**
1. First time: Write the code inline
2. Second time: Copy-paste and modify (yes, really!)
3. Third time: NOW extract to reusable function/class

**Why?**
- You need to see the pattern CLEARLY before abstracting
- Premature abstraction is worse than duplication
- Wrong abstractions are hard to undo

**Example:**
```ruby
# ‚ùå BAD: Premature abstraction
class BaseEmailSender
  def send_email; raise NotImplementedError; end
end
class WelcomeEmailSender < BaseEmailSender; end
# Only 1 use case - completely unnecessary!

# ‚úÖ GOOD: Wait for duplication
class WelcomeEmailSender
  def self.call(user)
    UserMailer.welcome(user).deliver_later
  end
end
# When you have 3+ similar senders, THEN extract common logic
```

## General Principles

1. **Follow SOLID Principles (But Don't Over-Apply Them)**
   - Single Responsibility: Each class has one job
   - Open/Closed: Open for extension, closed for modification
   - Liskov Substitution: Subclasses must be substitutable for base classes
   - Interface Segregation: Small, focused interfaces
   - Dependency Inversion: Depend on abstractions, not concrete implementations
   - **CRITICAL**: Dependencies must flow DOWNWARD (high-level ‚Üí abstraction ‚Üê low-level)
   - **IMPORTANT**: SOLID are guidelines, not laws. Simplicity trumps patterns.

2. **No Module-Level Code Execution**
   - NEVER put executable code at module level that runs at load time
   - Use Rails initializers for configuration: `config/initializers/`
   - Example BAD: `LLM::Registry.register(:foo, Bar)` at bottom of file
   - Example GOOD: Put registration in `config/initializers/`

## Ruby on Rails Best Practices

### Code Organization
- Use Rails conventions (model, controller, service, etc.)
- Service objects in `app/services/`
- Use concerns for shared behavior: `app/models/concerns/`, `app/controllers/concerns/`
- Use initializers for app configuration: `config/initializers/`
- Use PORO (Plain Old Ruby Objects) when appropriate

### Configuration
- Use `Rails.application.config` for app-wide config
- Environment-specific config in `config/environments/`
- Secrets in environment variables (ENV), never hardcode
- Use initializers for third-party library configuration

### Database
- Always use migrations for schema changes
- Use indexing for foreign keys and frequently queried columns
- Use database constraints (NOT NULL, foreign keys, unique)
- Avoid N+1 queries - use `includes`, `preload`, `eager_load`

### Models
- Keep models thin - business logic in services
- Use scopes for common queries
- Use validations at model level
- Use callbacks sparingly (they make testing hard)

### Controllers
- Keep controllers thin - delegate to services
- One action per controller method
- Use strong parameters
- RESTful routes preferred

### Services
- Use service objects for complex business logic
- One public method per service (`.call` or `.perform`)
- Return consistent data structures
- Handle errors explicitly - raise or return error object

### Background Jobs
- Use Active Job (Rails 8 uses Solid Queue)
- Idempotent jobs (safe to run multiple times)
- Handle failures gracefully
- Set retry strategy explicitly

### Testing
- Write tests for all new code
- Use RSpec conventions (describe, context, it)
- Use factories (FactoryBot) not fixtures
- Mock external services
- Test edge cases and error paths

### Dependencies
- Avoid circular dependencies
- Use dependency injection for testability
- Prefer composition over inheritance
- Use abstractions (interfaces/base classes) for flexibility

### Error Handling
- Use Rails' error handling (rescue_from in controllers)
- Log errors with context
- Use error tracking (Honeybadger)
- Never swallow exceptions silently
- Provide meaningful error messages

### Security
- Never trust user input
- Use strong parameters in controllers
- Sanitize HTML output
- Use parameterized queries (ActiveRecord does this)
- Keep gems updated (security patches)

## Vue.js Best Practices

### Component Organization
- One component per file
- Use Single File Components (.vue)
- Component names: multi-word, PascalCase
- Props: define types, required, defaults
- Emit events for parent communication

### State Management
- Use Pinia for global state
- Local state in component when possible
- Keep state flat and normalized
- Use getters for derived state

### Composition API
- Use `<script setup>` syntax
- Group related logic with composables
- Use `ref` for primitives, `reactive` for objects
- Destructure props with care (loses reactivity)

### Performance
- Use `v-memo` for expensive list items
- Lazy load routes and components
- Use computed for derived values
- Avoid watchers when computed can work

### Styling
- Use scoped styles in components
- Use Tailwind utility classes
- Consistent naming (BEM if using custom CSS)
- Mobile-first responsive design

## Code Style

### Ruby
- Follow RuboCop standard (https://rubystyle.guide/)
- 2 spaces for indentation
- Use `snake_case` for methods and variables
- Use `PascalCase` for classes and modules
- Use `SCREAMING_SNAKE_CASE` for constants
- Max line length: 120 characters
- No trailing whitespace
- String literals: prefer single quotes unless interpolation
- Use symbols for hash keys

### JavaScript/Vue
- Follow ESLint + Prettier standards
- 2 spaces for indentation
- Use `camelCase` for variables and functions
- Use `PascalCase` for components and classes
- Use `SCREAMING_SNAKE_CASE` for constants
- Max line length: 100 characters
- Always use `const` or `let`, never `var`
- Prefer arrow functions for callbacks
- Use template literals for string interpolation

## Anti-Patterns to Avoid

### Ruby/Rails
- ‚ùå Fat models - use services
- ‚ùå Fat controllers - use services
- ‚ùå Callback hell - be explicit
- ‚ùå Module-level executable code - use initializers
- ‚ùå Hardcoding - use configuration
- ‚ùå Direct class instantiation everywhere - use DI/registry
- ‚ùå Tight coupling - use abstractions
- ‚ùå God objects - follow SRP

### Vue
- ‚ùå Props mutation - emit events instead
- ‚ùå Direct DOM manipulation - use Vue directives
- ‚ùå Massive components - break them down
- ‚ùå Business logic in components - use composables/services
- ‚ùå Inline styles - use classes
- ‚ùå Deep prop drilling - use provide/inject or state management

## Architecture Patterns

### Registry Pattern (for plugins/extensions)
```ruby
# Good: Registry in initializer
Rails.application.config.after_initialize do
  MyRegistry.register(:type, MyClass)
end

# Bad: Registration at module level
MyRegistry.register(:type, MyClass)  # Runs at load time!
```

### Service Pattern
```ruby
# Good: Single responsibility, returns result
class CreateUser
  def self.call(params)
    user = User.create!(params)
    SendWelcomeEmail.call(user)
    user
  end
end

# Bad: Multiple responsibilities, unclear return
class UserService
  def create_and_email_and_log(params)
    # ...
  end
end
```

### Dependency Injection
```ruby
# Good: Inject dependencies
class Parser
  def initialize(client: OpenAIClient.new)
    @client = client
  end
end

# Bad: Hard-coded dependency
class Parser
  def initialize
    @client = OpenAI::Client.new  # Can't mock!
  end
end
```

## File Naming Conventions

### Ruby/Rails
- Models: `user.rb`, `job_application.rb`
- Controllers: `users_controller.rb`
- Services: `create_user.rb`, `parse_resume.rb`
- Jobs: `send_email_job.rb`
- Specs: `user_spec.rb`, `create_user_spec.rb`

### Vue
- Components: `UserProfile.vue`, `JobCard.vue`
- Composables: `useAuth.js`, `useJobs.js`
- Stores: `userStore.js`, `jobStore.js`
- Views/Pages: `HomePage.vue`, `ProfilePage.vue`

## Documentation

- Use YARD for Ruby documentation
- Use JSDoc for JavaScript documentation
- README.md for setup instructions
- Document public APIs
- Comment WHY not WHAT
- Keep comments up to date (or delete them)

## When to Refactor

Refactor when you see:
- Duplication (DRY)
- Long methods (>20 lines)
- Large classes (>200 lines)
- Complex conditionals (extract to methods)
- Hard to test code
- Violation of SOLID principles
- Unclear naming
- Tight coupling

## Git Practices

- Atomic commits (one logical change)
- Descriptive commit messages
- Branch per feature/fix
- Squash before merge (if appropriate)
- Never commit secrets
- Keep commits small and focused

## ü§ñ HOW CLAUDE SHOULD RESPOND TO PROMPTS

### Before Writing ANY Code - Validate Against These Principles:

**1. Check for Over-Engineering:**
```
User asks: "Create a base class for parsers"
Claude thinks:
  ‚ùì How many parsers exist? (If < 3, say NO to base class)
  ‚ùì What's duplicated? (If just config, use parameters not inheritance)
  ‚ùì Can I solve this with a function + config? (Usually YES)
  
  Response: "I see we only have 2 parsers with minimal duplication. 
            Instead of a base class, let's use a simple function with 
            configuration parameters. Here's why..."
```

**2. Challenge Unnecessary Abstractions:**
```
User asks: "Make this extensible with a plugin system"
Claude thinks:
  ‚ùì How many plugins exist now? (If < 5, registry is overkill)
  ‚ùì What are the actual requirements? (Often simpler solution works)
  
  Response: "A plugin system might be over-engineering. Currently we have 
            2 use cases. Let's use a simple hash lookup or case statement. 
            We can add a registry later if we get to 5+ plugins. Here's 
            the simpler approach..."
```

**3. Propose Simpler Alternatives:**
```
User asks: "Create ResumeParser and JobParser classes"
Claude thinks:
  ‚ùì Are these just configuration differences?
  ‚ùì Can one class with parameters work?
  
  Response: "These parsers only differ in configuration (schema, validator). 
            Instead of 2 separate classes, let's use one Parser class that 
            accepts the config as parameters. This is simpler and more 
            flexible. Here's how..."
```

**4. Explain Trade-offs:**

When suggesting code, ALWAYS explain:
- ‚úÖ Why this is the simplest solution
- ‚úÖ What problem it solves RIGHT NOW
- ‚úÖ When to add abstraction (e.g., "when we have 3+ similar cases")
- ‚ùå Don't just implement without explaining simplicity rationale

**Example Response Format:**
```
Here's how I'll implement this:

1. SIMPLICITY CHECK: We only have X use cases, so [simple solution]
2. PROPOSED SOLUTION: [code]
3. WHY IT'S SIMPLE: [explanation]
4. WHEN TO REFACTOR: If we add Y or Z, then we should consider [abstraction]

[Then show the code]
```

### Red Flags - When Claude Should Push Back:

**Immediately question if user asks for:**
- üö© "Create a Base class" (when < 3 subclasses exist)
- üö© "Make it extensible" (without specific requirements)
- üö© "Add a registry/factory" (when < 5 types exist)
- üö© "Abstract this" (without concrete duplication)
- üö© "Make it reusable" (without 3+ uses)

**Respond with:**
"I notice [pattern]. We currently have [count] use cases. The simplest 
solution is [X]. We can add [abstraction] later when we have [specific 
trigger]. Does this work for you?"

### Green Lights - When Abstraction Is Good:

**Add abstraction when:**
- ‚úÖ 3+ concrete, existing use cases with clear duplication
- ‚úÖ Clear pattern that's unlikely to change
- ‚úÖ Abstraction makes code significantly simpler (not complex)
- ‚úÖ Rails provides a standard pattern for this

**Example Good Cases:**
- Service objects (Rails pattern, reduces controller complexity)
- Concerns (Rails pattern, 3+ models need same behavior)
- Config classes (centralize scattered config)
- Validators (Rails pattern, reusable validations)

### Code Review Checklist (Claude Self-Check):

Before presenting code, ask yourself:
- [ ] Can I solve this with a simple function + parameters? (If YES ‚Üí do it)
- [ ] Am I creating files < 30 lines? (If YES ‚Üí combine them)
- [ ] Am I creating "Base" classes? (If YES ‚Üí do I have 3+ subclasses?)
- [ ] Am I building a framework? (If YES ‚Üí STOP, use Rails patterns)
- [ ] Would a Rails developer recognize this pattern? (If NO ‚Üí simplify)
- [ ] Can I explain this to a junior dev in 2 minutes? (If NO ‚Üí too complex)

### Example Interaction:

**User:** "Create parser classes for resume and job description"

**Claude Response:**
```
I'll create a single Parser class with configuration parameters instead of 
separate classes, because:

1. SIMPLICITY: We only have 2 parsers (need 3+ for base class pattern)
2. DIFFERENCE: They only differ in schema/validator config
3. RAILS WAY: Rails favors configuration over inheritance

Here's the approach:
[shows simple Parser.parse(text, schema:, validator:) code]

This is easier to test, easier to understand, and easier to extend (just 
pass different config). When we add more parser types (email, PDF, etc.) 
and see clear shared logic, we can refactor to a base class.

Does this work for you?
```

## Summary for Claude

**Your job is to:**
1. ‚úÖ Write the simplest code that solves the problem
2. ‚úÖ Challenge over-engineering (politely)
3. ‚úÖ Explain trade-offs between simple vs. complex
4. ‚úÖ Follow Rails conventions
5. ‚úÖ Suggest when to refactor later (with specific triggers)

**Your job is NOT to:**
1. ‚ùå Show off design patterns
2. ‚ùå Build extensible systems for 1-2 use cases
3. ‚ùå Create abstractions "just in case"
4. ‚ùå Build frameworks within the application
5. ‚ùå Assume the user knows what's over-engineered

**Remember:** Code that's easy to change is better than code that's "perfectly architected."
Simple, clear code > Complex, "elegant" code.
